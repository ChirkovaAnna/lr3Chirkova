#include "main.h"
    struct tune_up port;    //структура данных для настройки 
    struct lock ex;         //структура данных для переменных прерывания, и цикла вкл и выкл светодиодов        
    struct lock tim;        //структура данных для переменных таймера 
int main(void) //основная программа
{
    uint8_t pin = 131;      //Секретный код 10000011
    ex.pin_c = 0;           //Флаг, 1 - прерывание произошло 0 - прерывание не произошло 
    ex.a = 0;               //Переменная для счетчика вкл. и выкл. светодиода
    ex.i = 0;               //Переменная для счетчика вкл. и выкл. светодиода
    ex.x = 0;               //Переменная куда будет записываться значение с порта С
    tim.count1 = 2000-1;    //Константа для установки таймера на 1 секунду
    tim.count2 = 10000-1;   //Константа для установки таймера на 5 секунд
    tim.i = 1;              //контроль перехода в циск вкл. и выкл. светодиода (изменяется в обработчике прерывания таймера )
    tim.pin_c = 1;          //контроль всечения светодиода 1 - горит, 0 - не горит
    
    init_gpio ();           //функция настройки gpio
	init_IT_for_exemple();  //функция настройки прерываний
    init_timer();           //функция настройки таймера
    	
    while (1)
          {
              if(ex.pin_c == 1)                                 //если ex.pin_c = 1 то прерывание произошло и выполняется тело цикла 
                  {     ex.pin_c = 0;                           //устанавливаем ex.pin_c = 0, чтоб тело цикла if(ex.pin_c == 1) не выполнялось при повторном прохождении программы
                        tim.i = 0;                              //устанавливаем tim.i = 0, чтоб тело цикла if(tim.i==ex.i) (39 строка) выполнялась до того момента пока ex.i = 0 
                      ex.i = 0;                               //устанавливаем tim.i = 0, обновление счетчика while(ex.i<ex.a*2) вкл и выкл светодиода
                        ex.x = GPIOC->IDR &(GPIO_IDR_IDR0 | GPIO_IDR_IDR1 | GPIO_IDR_IDR2 | GPIO_IDR_IDR3 | GPIO_IDR_IDR4 | GPIO_IDR_IDR5 | GPIO_IDR_IDR6 | GPIO_IDR_IDR7) ; // считываем значиние с порта С (0-7 пинов)                               //устанавливаем i = 0
                    if (ex.x== pin)                             //если введенное число равно секретному коду, тело цикла выполняется
                        {		    
                            ex.a = 1;                           //значения "ex.a" определяется сколько раз должен загореться светодтод  
                            TIM4->ARR = tim.count2;             //установка таймера на count2=10000-1
                                                    }
                    else                  
                        {   ex.a = 3;                           //устанавливаем ex.a = 3
                            TIM4->ARR = tim.count1;             //установка таймера на count1=2000-1
                                                    }
                    TIM4->CNT=0;                                // сбрасываем значение таймера  
                }
            if(tim.i==ex.i)                                     //условие при котором будет выполняться тело цикла if, т.к. до прерывания у нас tim.i = 1 а ex.i = 0 то тело цикла не будет выполнятся т.е. светодиоды не переключаются 
                {
                    while(ex.i<ex.a*2)                          //пока ex.i меньше ex.a*2 цикл выполняется 
                        { 
                            if(tim.pin_c == 1)                  // если tim.pin_c равен 1, то тело цикла выполняется 
                                {
                                    GPIOA->BSRR = 0xff;         //установка 1 на пины от 0 до 7 (11111111 = 0xff)
                                    tim.pin_c = 0;              //устанавливаем tim.pin_c = 0, это нужно для того чтоб при следующем прохождении тело цикла if не выполнялось    
                                    ex.i++;                     // ex.i = ex.i + 1
                                    TIM4->CR1 |= TIM_CR1_CEN;   //включаем таймер                  
                                    break;                      //выход из цикла 
                                                            }               
                            else                                // если pin_time не равен 1
                                {
                                    GPIOA->BRR = 0xff;          // установка 0 на пины от 0 до 7 
                                    tim.pin_c = 1;              //устанавливаем tim.pin_c = 1
                                    ex.i++;                     // ex.i = ex.i + 1
                                    TIM4->CR1 |= TIM_CR1_CEN;   //включаем таймер
                                    break;                      //выход из цикла
                                }               
                        }  
                }
          }
}

void init_IT_for_exemple(void) //настройка прерывания
{
            port.bits = 0x00002000;                              //port.bits = EXTI_PR_PR13 | EXTI_RTSR_TR13 | EXTI_IMR_MR13
            RCC->APB2ENR = RCC->APB2ENR | RCC_APB2ENR_AFIOEN;    //Тактирование AFIO
            AFIO->EXTICR[3] = 0x0020;                            //Разрешаем прерывание 13 пина порта С
            EXTI-> PR    = port.bits;	                         //Сбрасываем флаг прерывания
            EXTI-> RTSR |= port.bits;                            //Прерывание по спаду импульса
            EXTI-> IMR  |= port.bits;                            //Включаем прерывание 
            NVIC_EnableIRQ(EXTI15_10_IRQn);                      //Разрешаем прерывание в контроллере прерываний
}
void init_timer() //настройка таймера
{
            RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;                  // Разрешение прохождение сигнала Timer4
            TIM4->PSC = (SystemCoreClock/2) / 1000 - 1;          // ((8МГц/2)/1000-1)=3999 предделитель. 
                                                                 //Получаем 2000 тиков в секунду, т.е.  один тик = 0.5 мс
            TIM4->ARR = tim.count1;                              // Установка таймера на 1 секунду, 2000*0.5мс = 1 сек, т.е. прерывание будет выполняться раз в секунду 
            TIM4->DIER |= TIM_DIER_UIE;                          // разрешаем прерывание по переполнению
            NVIC_EnableIRQ(TIM4_IRQn);                           // глобально разрешаем прерывание
}
void init_gpio (void)
{ 
    port.bits = (GPIO_CRL_CNF0_0 | GPIO_CRL_CNF1_0 | GPIO_CRL_CNF2_0 | GPIO_CRL_CNF3_0 | GPIO_CRL_CNF4_0 | GPIO_CRL_CNF5_0 | GPIO_CRL_CNF6_0 | GPIO_CRL_CNF7_0); // в port.bits хронятся нам нужные биты для настройки gpio
            //порт А
            RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;	                 // Включаем тактирование порта А
            GPIOA->CRL &= ~(GPIO_CRL_MODE | GPIO_CRL_CNF);       // сброс режимов порта
            GPIOA->CRL |= GPIO_CRL_MODE;	                     // установка режима порта 
            //порт С
            RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;                  // Включаем тактирование порта C
            GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13); 	 // Сброс режимов порта C пина 13
            GPIOC->CRH |= GPIO_CRH_CNF13_0;     	             // установка режима порта 
    
            GPIOC->CRL &= ~(GPIO_CRL_MODE | GPIO_CRL_CNF); 	     // Сброс режимов порта C
            GPIOC->CRL |= port.bits;                             // установка режима порта
}
// обработчик прерывания
void EXTI15_10_IRQHandler (void)
    {
            EXTI->PR |= GPIO_PIN_13;                             //Сбрасываем флаг прерывания
            ex.pin_c = 1;                                        //устанавливаем ex.pin_c = 1
    }                
// обработчик прерывания таймера
void TIM4_IRQHandler(void) 
    {
            TIM4->SR &= ~TIM_SR_UIF;                             //сбрасываем прерывание
            tim.i++;                                             //устанавливаем tim.i = tim.i + i
            TIM4->CR1 &= ~TIM_CR1_CEN;                           //выключение таймера
    }
