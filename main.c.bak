/********************************************************************************
  Имя файла 	: main.c
   Проект		: ex05_GPIO_logicF
   Автор 		: Парунов А.В.
   Версия		: V1.0
   Дата			: 30.05.2021
   Описание		: Пример программы чтения состояний 4-х кнопок (x1, x2, x3, x4)
				  осуществляет вычиление логической функции F(x1, x2, x3, x4) и 
				  зажигает светодиод в зависимости от значения функции F
 				  C и C++. Данный пример написан в рамках курса 
 				  "Цифровые устройства и микропроцессоры"
				  
				  Фунция задана таблицей истинности
				  -------------------
				  | x4 x3 x2 x1 | F |
				  -------------------
				  | 0  0  0  0  | 1 |
				  | 1  0  0  0  | 1 |
				  | 0  1  0  0  | 1 |
				  | 1  1  0  0  | 1 |
				  | 0  0  1  0  | 0 |
				  | 1  0  1  0  | 0 |
				  | 0  1  1  0  | 0 |
				  | 1  1  1  0  | 0 |
				  | 0  0  0  1  | 0 |
				  | 1  0  0  1  | 0 |
				  | 0  1  0  1  | 0 |
				  | 1  1  0  1  | 0 |
				  | 0  0  1  1  | 0 |
				  | 1  0  1  1  | 0 |
				  | 0  1  1  1  | 1 |
				  | 1  1  1  1  | 0 |
				  -------------------
				  
				  После мнимизации получаем следующию функцию
				  F(x1, x2, x3, x4) = ~x1 & ~x2 | x1 & x2 & x3 ~x4
				  
				  Кнопки подключены к порту C к следующим пинам:
				  pin 0 - x1
				  pin 1 - x2
				  pin 2 - x3
				  pin 3 - x4
				  
				  Светодиод поключени к порту A, pin - 5
				  
				  В программе предложены два варианта реализации вычисления 
				  логической функции logic_func и logic_func2
				  для реализации своего варианта задания, необходимо выбрать
				  только одну функцию

;*******************************************************************************
;	На данном примере студенты должны познакомиться с программным доступом к порту
;   для ввода и вывода информации. 
;*******************************************************************************/


#include "stm32f10x.h" 

// __STATIC_INLINE - этот модификатор позволяет в месте вызова функции 
// подставять тело функции. Данный модификатор используется когда функции небольшие
// и затраты на вызов функции будут приводить к лишним накладным расходом
// Данный модификатор позволяет разбить, программу на элементарные функции, но 
// компилятор из не будет создавать.


// Функция  init_led - инициализация порта к которому подключен светодиод
// port A pin 5

__STATIC_INLINE void init_led()
{
	// Вкючаем тактирование на порту.
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	// сброс режимов порта
	GPIOA->CRL &= ~(GPIO_CRL_MODE5 | GPIO_CRL_CNF5);
	// установка скорости порта 10МГ
	GPIOA->CRL |= GPIO_CRL_MODE5_0;
}


// Функция инициализации портов к которым подключены кнопки
// Кнопки подключениы к порту A
//	  pin 0 - x1
//	  pin 1 - x2
//	  pin 2 - x3
//	  pin 3 - x4

__STATIC_INLINE void init_buttons()
{
	// Включаем тактирование порта C
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
	// Сброс режимов порта C pin - 0
	GPIOC->CRH &= ~(GPIO_CRL_MODE0 | GPIO_CRL_CNF0);
	GPIOC->CRH |= GPIO_CRL_CNF0_0;
	// Сброс режимов порта C pin - 1
	GPIOC->CRH &= ~(GPIO_CRL_MODE1 | GPIO_CRL_CNF1);
	GPIOC->CRH |= GPIO_CRL_CNF1_0;
	// Сброс режимов порта C pin - 2
	GPIOC->CRH &= ~(GPIO_CRL_MODE2 | GPIO_CRL_CNF2);
	GPIOC->CRH |= GPIO_CRL_CNF2_0;
	// Сброс режимов порта C pin - 3
	GPIOC->CRH &= ~(GPIO_CRL_MODE3 | GPIO_CRL_CNF3);
	GPIOC->CRH |= GPIO_CRL_CNF3_0;
}

// функция считывания состояния  4-х кнопок за одни запрос
// возвращаемое значение состояние кнопок 
//	  разряд 0 - x1
//	  разряд 1 - x2
//	  разряд 2 - x3
//	  разряд 3 - x4

__STATIC_INLINE uint16_t get_buttons() 
{
	return GPIOC->IDR & (GPIO_IDR_IDR0 | GPIO_IDR_IDR1 | GPIO_IDR_IDR2 | GPIO_IDR_IDR3) ;	
}

// Функции выделения разряда из группы состояний кнопок.
// перевый параметр state - состояник кнопок, второй pin - номер разряда
// возвращаемое значение - состояние разряда
__STATIC_INLINE int16_t get_button(uint16_t state, int8_t pin) 
{
	// сдвигаем состоние вправо на pin разрядов, так чтобы нужный разряд 
	// оказался в нулевом разряде и выделаяем его функцией "И"
	return (state >> pin) & 1u;	
}

// Функция вычисления логического выражения logic_func - первый вариант. 
// первый параметр state - состояние кнопок
// возвращаемое значение - результат логического выражения
__STATIC_INLINE int16_t logic_func(uint16_t state) 
{
	int16_t x1,x2,x3,x4;
	
	x1=get_button(state, 0);
	x2=get_button(state, 1);
	x3=get_button(state, 2);
	x4=get_button(state, 3);
	
	return (~x1 & ~x2 | x1 & x2 & x3 & ~x4) & 1u; 
}

// Функция вычисления логического выражения logic_func2 - второй вариант. 
// первый параметр state - состояние кнопок
// возвращаемое значение - результат логического выражения
//
// ВНИМАНИЕ!!
// Нужно использовать только один вариант вычислений, если вы используете первый
// вариант, тогда необходимости в этой функции.
// если вы используете второй вариант, тогда функции logic_func и get_button не нужны 
__STATIC_INLINE int16_t logic_func2(uint16_t state) 
{
	return (!( state & 0b0011) || !( state & 0b1111 ^ 0b0111 )); 
}

// функция зажигания светодиода
__STATIC_INLINE void led_on() 
{
	GPIOA->BSRR = (1u<<5);
}

// функция гашения светодиода
__STATIC_INLINE void led_off() 
{
	GPIOA->BRR = (1u<<5);
}

int main(void)
{
	uint16_t btns; // переменная в которой хранится состояние кнопо
	
	init_led();
	init_buttons();
	
	while(1)
	{
		btns=get_buttons();
		if( logic_func(btns))
			led_on();
		else
			led_off();
	}
}
